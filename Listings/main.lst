C51 COMPILER V9.59.0.0   MAIN                                                              12/08/2018 18:11:36 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REG52.H>
   2          #include <stdio.h>
   3          
   4          /*------------------------------------------------
   5          The following string is the stuff we're gonna
   6          send into the serial port.
   7          ------------------------------------------------*/
   8          
   9          /*---------------------------------------------------------
  10          Timer 1 Overflow Interrupt
  11          ---------------------------------------------------------*/
  12          unsigned int T1_ISR_count = 0;
  13          void T1_ISR(void) interrupt 3 { 
  14   1        T1_ISR_count++;
  15   1        TF1 = 0; // Reset the interrupt request
  16   1      }
  17          
  18          unsigned char key_i=0;
  19          
  20          // Testing by use of word ".tie5Ronal"
  21          //char xdata key[11] = {'.', 't', 'i', 'e', '5', 'R', 'o', 'n', 'a', 'l', '\0'};
  22          signed char test[11] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '\0'};
  23          
  24          
  25          // Arrays to save time intervals between each user press
  26          
  27          unsigned char xdata msg1 [] = "User A training end\nNow User B, Enter '1234567890' 5 times\n";
  28          unsigned char xdata msg2 [] = "User B training end\nNow any user enters 1234567890\n";
  29          
  30          unsigned char trials_num = 5; // # of entries needed to be entered by current user
  31          
  32          
  33          // state_bit
  34          // 0 :userA training phase
  35          // 1 :means userB training phase
  36          // 2 :means entering test phase  
  37          unsigned char states_bit = 0;
  38            
  39          
  40          
  41          void main (void) {
  42   1        unsigned int time_between_chars_typed_userA[10];
  43   1        unsigned int time_between_chars_typed_userB[10];
  44   1        unsigned int time_between_chars_typed_recognize[10];
  45   1        
  46   1        /*Note : timer takes 135 micro seconds to overflow*/
  47   1        
  48   1        
  49   1        /*------------------------------------------------
  50   1          Setup the timer 1 to start in mode 2 with auto reload value of 0.
  51   1        ------------------------------------------------*/
  52   1                  // Setting the global interrupt
  53   1        SCON = 0x50;    // SCON:  mode 1, 8-bit UART, enable receiver
  54   1        TMOD |= 0x20;   // TMOD:  timer 1, mode 2, 16-bit 
C51 COMPILER V9.59.0.0   MAIN                                                              12/08/2018 18:11:36 PAGE 2   

  55   1        TH1 = 0x00;     // TH1:   Seting timer auto reload value to 0
  56   1        TR1 = 1;        // TR1:   timer 1 run
  57   1        TI = 1;         // TI:    set TI to send first char of UART
  58   1        IT1 = 0;
  59   1        //PCON |= 0x80;
  60   1        
  61   1        /*--------------------------------------
  62   1          Enable interrupts for timer 1.
  63   1        --------------------------------------*/
  64   1        ET1 = 1;        // Setting Timer 1 interrupt
  65   1        EA = 1; 
  66   1      
  67   1      
  68   1        // Program Logic follows
  69   1        printf("User A,Enter '1234567890' 5 times\n");
  70   1        //printf("#%u Entry\n", trials_num);
  71   1      
  72   1        while (1) {
  73   2          
  74   2      
  75   2          signed char x = _getkey();
  76   2          
  77   2          if(states_bit == 0 && trials_num == 0){
  78   3            // Just got last entry by User A @(Training Session)
  79   3            trials_num = 5;   // Reset # of needed entries for (Training Session) by User B
  80   3            states_bit = 1;   // Set to User B (Training Session) 
  81   3          
  82   3          } else if(states_bit == 1 && trials_num == 0 ) {
  83   3            // Just got last entry by User B @(Training Session)
  84   3            states_bit = 2; // Set to (Test Session)
  85   3            
  86   3          }
  87   2          
  88   2          
  89   2          if (x == test[key_i]) {
  90   3            // a Key was pressed Logic
  91   3            if (key_i != 0 && states_bit == 0) {
  92   4              time_between_chars_typed_userA[key_i-1] += (T1_ISR_count / 5);
  93   4              //printf("%u\n", time_between_chars_typed_userA[key_i-1]);
  94   4            
  95   4            } else if(key_i != 0 && states_bit == 1) {
  96   4              time_between_chars_typed_userB[key_i-1] += (T1_ISR_count / 5);
  97   4              //printf("%u\n", time_between_chars_typed_userB[key_i-1]);  
  98   4              
  99   4            } else if( key_i != 0 && states_bit == 2) {
 100   4              time_between_chars_typed_recognize[key_i-1] = T1_ISR_count;
 101   4              //printf("%u\n", time_between_chars_typed_recognize[key_i-1]);  
 102   4              
 103   4            }       
 104   3            key_i++;
 105   3            T1_ISR_count = 0;       
 106   3        
 107   3          } else { 
 108   3            printf("Repeat\n");
 109   3            key_i = 0;
 110   3            // TODO does the counter reset in this case?
 111   3          }
 112   2          
 113   2          
 114   2          if (key_i == 10) {
 115   3            // Sequence entered correctly Logic
 116   3            key_i = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              12/08/2018 18:11:36 PAGE 3   

 117   3            
 118   3            if(states_bit == 0 || states_bit == 1)
 119   3              // It is a (Training Session)
 120   3              trials_num --;
 121   3            
 122   3            if(states_bit == 0 && trials_num == 0){
 123   4              printf("%s\n" , msg1);
 124   4              
 125   4            } else if(states_bit == 1 && trials_num == 0){
 126   4              printf("%s\n", msg2);
 127   4          
 128   4            } else if(states_bit == 2) {
 129   4              // Detection Logic
 130   4                      
 131   4              unsigned char feature_i = 0;
 132   4              
 133   4              signed int error_diff = 0;
 134   4              
 135   4              unsigned long int sum_sq_err_A = 0;
 136   4              unsigned long int sum_sq_err_B = 0;
 137   4              
 138   4              
 139   4              for(; feature_i < 10; feature_i++) {
 140   5                error_diff = (time_between_chars_typed_recognize[feature_i] - time_between_chars_typed_userA[feature_
             -i]);
 141   5                sum_sq_err_A += (error_diff*error_diff);
 142   5                
 143   5                error_diff = (time_between_chars_typed_recognize[feature_i] - time_between_chars_typed_userB[feature_
             -i]);
 144   5                sum_sq_err_B += (error_diff*error_diff);
 145   5              }
 146   4              
 147   4              if(sum_sq_err_A > sum_sq_err_B) {
 148   5                printf("User B\n");
 149   5              } else {
 150   5                printf("User A\n");
 151   5              } 
 152   4              //printf("Oh! no I can not take a guess!");
 153   4              
 154   4            }
 155   3            
 156   3          }
 157   2        }
 158   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    495    ----
   CONSTANT SIZE    =     63    ----
   XDATA SIZE       =    112    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
